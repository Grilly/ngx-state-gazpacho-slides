<!-- Next Slides -->
<section>
    <h2>NGRX Store: Reducers</h2>
    <p>State changes are handled by pure functions called reducers that take the current state and the latest action to compute a new state.</p>
    <p>Reducers and Effects should be the decision makers in the application</p>
    <p>Avoid nested conditionaks in reducers and effects (Do not subtype actions -> Add menu item; subtype: burger or taco; Better stack case statements; Better put multiple ActionTypes in the Effect)</p>
    <p>responsible for handling transitions from one state to the next state in your application. Reducer functions handle these transitions by determining which actions to handle based on the type</p>
    <p>Reducer functions are pure functions</p>
    <p>handle each state transition synchronously</p>
    <p>Each reducer function takes the latest Action dispatched, the current state, and determines whether to return a newly modified state or the original state</p>
    <p>The reducer function's responsibility is to handle the state transitions in an immutable way</p>
    <code><pre>
        export function reducer(
            state = initialState,
            action: Scoreboard.ActionsUnion
            ): State {
            switch (action.type) {
                case Scoreboard.ActionTypes.IncrementHome: {
                return {
                    ...state,
                    home: state.home + 1,
                };
                }
            
                case Scoreboard.ActionTypes.IncrementAway: {
                return {
                    ...state,
                    away: state.away + 1,
                };
                }
            
                case Scoreboard.ActionTypes.Reset: {
                return action.payload; // typed to { home: number, away: number }
                };
                }
            
                default: {
                return state;
                }
            }
        }
    </pre></code>
    <p>The action types defined with your actions are reused in your reducer functions as case statements</p>
    <p>Each action handles the state transition immutably. This means that the state transitions are not modifying the original state, but are returning a new state object using the spread operator. The spread syntax copies the properties from the current state into the object, creating a new reference. This ensures that a new state is produced with each change, preserving the purity of the change. This also promotes referential integrity, guaranteeing that the old reference was discarded when a state change occurred.</p>
    <p>When an action is dispatched, all registered reducers receive the action. Whether they handle the action is determined by the switch statement. For this reason, each switch statement always includes a default case that returns the previous state when the reducer function doesn't need to handle the action.</p>
    <h3>MetaReducers</h3>
    <p>Meta-reducers
            @ngrx/store composes your map of reducers into a single reducer.
            
            Developers can think of meta-reducers as hooks into the action->reducer pipeline. Meta-reducers allow developers to pre-process actions before normal reducers are invoked.
            
            Use the metaReducers configuration option to provide an array of meta-reducers that are composed from right to left.
            
            Note: Meta-reducers in NgRx are similar to middleware used in Redux.</p>
</section>
<section>
    <h2>NGRX Store: Reducer & State 1</h2>
    <h3>Registering Root State</h3>
    <p>Do only once in the Projekt</p>
    <code><pre>
        import { NgModule } from '@angular/core';
        import { StoreModule } from '@ngrx/store';
        import { scoreboardReducer } from './scoreboard.reducer';
        
        @NgModule({
            imports: [StoreModule.forRoot({ game: scoreboardReducer })],
        })
        export class AppModule {}
    </pre></code>
    <code><pre>
        {} // The store
    </pre></code>
    <p>Registering states with StoreModule.forRoot() ensures that the states are defined upon application startup. In general, you register root states that always need to be available to all areas of your application immediately.</p>
    <p>This registers your application with an empty object for the root state.</p>
</section>
<section>
    <h2>NGRX Store: Reducer & State 2</h2>
    <h3>Registering Feature State</h3>
    <p>For additional states registered with feature NgModule's</p>
    <code><pre>
        import { NgModule } from '@angular/core';
        import { StoreModule } from '@ngrx/store';
        import { scoreboardReducer } from './scoreboard.reducer';
        
        @NgModule({
            imports: [StoreModule.forFeature('game', scoreboardReducer)],
        })
        export class ScoreboardModule {}
    </pre></code>
    <p>Add ScoreboardModule to AppModule</p>
    <code><pre>
        import { NgModule } from '@angular/core';
        import { StoreModule } from '@ngrx/store';
        
        @NgModule({
            imports: [StoreModule.forRoot({}), ScoreboardModule],
        })
        export class AppModule {}
    </pre></code>
    <p>Once the ScoreboardModule is loaded, the game key becomes a property in the object and is now managed in the state.</p>
    <code><pre>
        { game: { home: 0, away: 0 } }
    </pre></code>
    <p>You use feature states to build up your state object over time and through different feature areas.</p>
    <p>Can be loaded eagerly or lazily, depends on the application</p>
</section>
<section>
    <h2>NGRS Selectors</h2>
    <p>create gets the data needed for the component and so t</p>
    <p>container haben view model and components haben Inputs; Model (State) wird von Container durch Actions angepasst und durch Selectoren gelesen</p>
    <p>Selectors are pure functions used to select, derive and compose pieces of state.</p>
    <p>Selectors are queries to your store</p>
    <p>Selectors are pure functions used for obtaining slices of store state</p>
    <p>Selectors provide many features when selecting slices of state.</p>
    <ul>
        <li>Portable</li>
        <li>Memoization</li>
        <li>Composition</li>
        <li>Testable</li>
        <li>Type-safe</li>
    </ul>
    <p>Benefits</p>
    <ul>
        <li>Provide a query API for views</li>
        <li>Reduce action boilerplate</li>
        <li>Simplify Reducers</li>
        <li>Memoization</li>
        <li>Routing state</li>
    </ul>
    <img src="chapters/images/StateManagement_Redux_ToddMotto.jpg">
    <img src="chapters/images/StateManagement_Redux_Selectors_ToddMotto.jpg">
    <h3>createSelector</h3>
    <h3>createFeatureSelector: for FeatureModules</h3>
    <p>Creation</p>
    <code><pre>
        const getAllOrders = createFeatureSelector('orders');
        const getCurrentOrders = createSelector(
            getAllOrders,
            orders => orders.filter(o => o.isActive) // Projector function 
        );
        const getPastOrders = createSelector(
            getAllOrders,
            orders => orders.filter(o => !o.isActive) // Projector function 
        );
    </pre></code>
    <p>Usage</p>
    <code><pre>
        constructor(private store: Store<AppState>) {}
        ngOnInit() {
            const orders$ = this.store.select(getCurrentOrders;
        }
    </pre></code>
    <p>Selectors are reactive: When adding an active order the getAllOrders and getCurrentOrders selector will update not the getPastOrders selector </p>
    <p>getOrderById</p>
    <code><pre>
        const getOrderById = (id) => createSelector(
            getAllOrders,
            orders => order.find(o => o.id === id) // problem with 10k items -> Better use ngrx/entity
        );
    </pre></code>
    <p>Selectors Weiter TODO: https://ngrx.io/guide/store/selectors</p>
</section>
<section>
    <h2>Effects TODO</h2>
    <p>https://ngrx.io/guide/effects</p>
</section>
<section>
    <h2>Entities TODO</h2>

    <p>https://ngrx.io/guide/entity</p>
    <p>discribe ids -> always UUID (-> string)</p>
    <p>id comes from the backend</p>
    <p>Entity kommt in den Store, wenn sich etwas im Backend Ã¤ndert</p>
</section>
<section>
    <h2>Normalizer</h2>
    <p>Initial 1 JSON mit allen Daten</p>
</section>