<section>
    <h1>Introduction</h1>
</section>
<section>
    <h2>Challenge</h2>
    <p class="fragement">Observing attribute changes</p>
    <pre><code data-trim class="json">
    [{
        "items": [
            {
                "id": 1
                "name": "Fahrrad",
                "price": 500,
                "currency": "Euro"
            },
            {
                "id": 2
                "name": "Laptop"
            },
        ]
    }, {...}]
    </code></pre>
    <aside class="notes">
        TODO Motivation/Why Tonspur und Content
        our code must manage more state than ever before
        This state can include server responses and cached data, as well as locally created data that has not yet been persisted to the server. UI state is also increasing in complexity, as we need to manage active routes, selected tabs, spinners, pagination controls, and so on.
        Managing this ever-changing state is hard. If a model can update another model, then a view can update a model, which updates another model, and this, in turn, might cause another view to update
        As developers, we are expected to handle optimistic updates, server-side rendering, fetching data before performing route transitions, and so on

        TODO Additional Whys
        React How-To, we get to a couple of indications of when we benefit from Flux:

        React components are arranged in a hierarchy. Most of the time, your data model also follows a hierarchy. In these situations Flux doesn’t buy you much. Sometimes, however, your data model is not hierarchical. When your React components start to receive props that feel extraneous, or you have a small number of components starting to get very complex, then you might want to look into Flux.

        Also if we dig into the issues we get these recommendations as well. A store-like architecture is recommended if:

        You have a piece of data that needs to be used in multiple places in your app, and passing it via props makes your components break the single-responsibility principle (i.e. makes their interface make less sense)

        But also there is this scenario:

        There are multiple independent actors (generally, the server and the end-user) that may mutate that data

        multiple actors editing concurrently the same data.

        For example, we are passing something 5 or 10 levels up the component tree. The leaves of the tree know what to do with it, but for all the components in the middle the input feels extraneous and makes that component less reusable and more tied to the application. But that is just one example.

        There are situations where components are dependent on each other at completely different points in the component tree, and passing inputs 10 levels up the tree and callback functions 10 levels down the tree then 5 levels up another branch is not scalable in complexity.

        pass data deep down the tree, and react to events several levels up the component tree

        Another issue is, we have sibling components in the tree that are interdependent, and that represent different view for the same data on the screen, like a list of folders with unread messages, and a total unread messages counter on the page header.

        Passing only inputs to components won't scale in complexity.
    </aside>
</section>
<section>
    <h2>Complexity</h2>
    TODO Content Komplexität erklären
    <p>This complexity is difficult to handle as we're mixing two concepts that are very hard for the human mind to
        reason about: mutation and asynchronicity.</p>
    <table>
        <tr>
            <th style="border:none" rowspan="4">
                <div style="transform: translate(20px, 150px) rotate(270deg)"><span>Shared?</span></div>
            </th>
            <th colspan="3" style="text-align: center;">Mutable?</th>
        </tr>
        <tr>
            <th></th>
            <th>no</th>
            <th>yes</th>
        </tr>
        <tr>
            <td>no</td>
            <td>OK</td>
            <td>OK</td>
        </tr>
        <tr>
            <td>yes</td>
            <td>OK</td>
            <td>CHAOS</td>
        </tr>
    </table>
</section>
<section>
    <h2>Hack Solution: Use plain RxJS</h2>
    <pre><code data-trim class="typescript">
        getSafes(): Observable&lt;Safe[]> {
        getSafe(safeId: string): Observable&lt;Safe> {
        getItems(safeId: string): Observable&lt;SafeItem[]> {
        getItem(safeId: string, itemId: string): Observable&lt;SafeItem> {
    </code></pre>
    <p class="fragment">Services manage state using RxJS</p>
    <p class="fragment">Services are for behavior, not for state.</p>
    <p class="fragment">RxJS HELL</p>
    <p class="fragment">Architecture Pattern to solve this: flux</p>
    TODO content gut genug
</section>
<section>
    <h2>Solution</h2>
    <h3>Redux</h3>
</section>
<section>
    <h2>Redux</h2>
    <p>Redux is a predictable state container for JavaScript apps.</p>
    <p>Creator: Dan Abramov</p>
    <img src="chapters/images/StateManagement_Redux_ToddMotto.jpg">
</section>
<section>
    <h2>When to use Redux</h2>
    <p>
        Here are some suggestions on when it makes sense to use Redux:
        You have reasonable amounts of data changing over time
        You need a single source of truth for your state            
        You find that keeping all your state in a top-level component is no longer sufficient
        Yes, these guidelines are subjective and vague, but this is for good reason. The point at which you should integrate Redux into your application is different for every user and different for every application.
    </p>
</section>
<section>
    <h2>What is Redux: STORE</h2>
    <p>your app’s state is described as a plain object</p>
    <p>State of TODO app</p>
    <code><pre>
    {
        todos: [{
            text: 'Eat food',
            completed: true
        }, {
            text: 'Exercise',
            completed: false
        }],
        visibilityFilter: 'SHOW_COMPLETED'
    }
    </pre></code>
    <p>Model without setters</p>
    <p>No arbitrary model changes</p>
</section>
<section>
    <h2>Redux Action</h2>
    <p>To change something in the state, you need to dispatch an action.</p>
    <p>An action is a plain JavaScript object</p>
    <code><pre>
        { type: 'ADD_TODO', text: 'Go to swimming pool' }
        { type: 'TOGGLE_TODO', index: 1 }
        { type: 'SET_VISIBILITY_FILTER', filter: 'SHOW_ALL' }
    </pre></code>
    <p>-> If something changed, we know why it changed.</p>
    <p>Action = breadcrumbs of what has happened</p>
</section>
<section>
    <h2>Redux Reducer</h2>
    <p>Reducer function ties state and actions together</p>
    <p>function that takes state and action as arguments, and returns the next state of the app</p>
    <p>Usually multiple smaller reducers that manage parts of the app and one that manages the smaller reducers</p>
    <p>see https://redux.js.org/introduction/coreconcepts for examples</p>
</section>
<section>
    <h2>3 Principles of Redux</h2>
    <ol>
        <li class="fragement">Single source of truth</li>
        <li class="fragement">State is read-only</li>
        <li class="fragement">Changes are made with pure functions</li>
    </ol>
    <aside class="notes">
        1. The state of your whole application is stored in an object tree within a single store. => This makes it easy to create universal apps, as the state from your server can be serialized and hydrated into the client with no extra coding effort. A single state tree also makes it easier to debug or inspect an application; it also enables you to persist your app's state in development, for a faster development cycle. Some functionality which has been traditionally difficult to implement - Undo/Redo, for example - can suddenly become trivial to implement, if all of your state is stored in a single tree.
        2. The only way to change the state is to emit an action, an object describing what happened. => This ensures that neither the views nor the network callbacks will ever write directly to the state. Instead, they express an intent to transform the state. Because all changes are centralized and happen one by one in a strict order, there are no subtle race conditions to watch out for. As actions are just plain objects, they can be logged, serialized, stored, and later replayed for debugging or testing purposes.
        3. To specify how the state tree is transformed by actions, you write pure reducers. => Reducers are just pure functions that take the previous state and an action, and return the next state. Remember to return new state objects, instead of mutating the previous state. You can start with a single reducer, and as your app grows, split it off into smaller reducers that manage specific parts of the state tree. Because reducers are just functions, you can control the order in which they are called, pass additional data, or even make reusable reducers for common tasks such as pagination.
    </aside>
</section>
